\chapter{Аналитический раздел}

В данном разделе представлен анализ существующих алгоритмов построения изображений и выбор подходящих алгоритмов для решения задачи.

\section{Формализация объектов сцены}
Сцена состоит из следующих объектов:

\begin{itemize}[label*=---]
	\item объект (стартовый или получаемый) --- трехмерная модель, представляющая собой каркасное тело;
	\item источник света --- вектор направления света;
	\item камера --- характеризуется своим положением и направлением просмотра.
\end{itemize}

\newpage

\section{Анализ способов описания трехмерных моделей}

В компьютерной графике в основном используют три типа представления трехмерных объектов~\cite{Kosnikov}: каркасная, поверхностная и твердотельная модели.
Они предоставляют различные способы представления объектов и позволяют 
достичь правильного отображения их формы и размеров на сцене.\\ %\cite{Kosnikov}

% \subsection{Каркасная модель}

Каркасная модель это простейший вид моделей. В этой модели задается информация о вершинах и ребрах объектов. Этим видам модели присущ весьма существенный недостаток: не всегда модель правильно передает представление об объекте. К преимуществам же можно отнести сравнительно низкое число затрачиваемой памяти.\\

% \subsection{Поверхостная модель}

Поверхностные модели несут информацию обо всех точках
пространства, принадлежащих поверхности объекта, а внутренние точки в них
не учитываются. К недостаткам данной модели относится отсутствие информации о том, с какой стороны поверхности находится материал.\\ % \cite{Kosnikov}

% \subsection{Твердотельная модель}

Твердотельная модель отличается от поверхностной наличием информации о том, где расположен материал. Проще всего это можно сделать путем указания направления внутренней нормали.~\cite{Kosnikov}\\

% \subsection{Выбор способа описания модели}

Для решения поставленной задачи выбрана каркасная модель, так как для осуществления морфинга необходимо знать информацию только о вершинах и ребрах объекта. Хранить остальную информацию об объекте избыточно. 

\newpage

\section{Анализ алгоритмов удаления невидимых поверхностей}

Алгоритмы удаления невидимых линий и поверхностей определяют, какие линии, поверхности или объемы видимы или невидимы для наблюдателя, находящегося в определенной точке пространства.\\

% \subsection{Алгоритм Робертса}

Алгоритм Робертса удаляет из каждого тела те ребра или грани, которые скрываются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, скрываются этими телами. При этом вычислительная трудоемкость алгоритма Робертса растет теоретически, как квадрат числа объектов.\\ %\cite{REMOVE_FACES}

% \subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта чаше всего используется для удаления невидимых линий трехмерного представления функций, описывающих поверхность в виде $F(x, y, z) = 0$.

Идея метода заключается в сведении трехмерной задачи к двумерной путем пересечения исходной поверхности последовательностью параллельных секущих плоскостей, имеющих постоянные значения координаты $z$.

Алгоритм сначала упорядочивает плоскости $z = const$ по возрастанию расстояния до них от точки наблюдения. Затем для каждой плоскости, начиная с ближайшей к точке наблюдения, строится кривая, лежащая на ней, т.е. для каждого значения координаты $х$ в пространстве изображения определяется соответствующее значение $y$.

Если на текущей плоскости при некотором заданном значении x соответствующее значение у на кривой больше значения y для всех предыдущих кривых при этом значении x, то текущая кривая видима в этой точке; в противном случае она невидима.~\cite{REMOVE_FACES}\\

% \subsection{Алгоритм Коэна --- Сазерленда}

%Алгоритм Коэна --- Сазерленда разделяет плоскость на девять частей прямыми, которые образуют стороны прямоугольника. Каждой из девяти частей присваивается четырехбитный код.

%Окну присваивается код $0000$. Конечным точкам отрезка приписывается 4-битный код <<вне/внутри>> в зависимости от нахождения отрезка в соответствующей подобласти. Каждому биту присваивается значение 1 в соответствии со следующим правилом.

%Бит 1 --- точка находится выше окна;

%Бит 2 --- точка находится ниже окна;

%Бит 3 --- точка находится справа от окна;

%Бит 4 --- точка находится слева от окна;

%Иначе биту присваивается нулевое значение.

%\includeimage
%{CohenSutherland}
%{f}
%{!ht}
%{0.50\textwidth}
%{Разбиение на подобласти в методе Коэна---Сазерленда}

%Алгоритм определяет код конечных точек отрезка. Если оба кода равны нулю, то отрезок полностью находится в прямоугольнике. Если битовое И кодов не равно нулю, то отрезок не пересекает прямоугольник (так как это значит, что обе конечные точки отрезка находятся с одной стороны прямоугольника). В прочих случаях алгоритм выбирает конечную точку, находящуюся вне прямоугольника, находит ближайшую к ней точку пересечения отрезка с одной из линий, образующей стороны прямоугольника, и использует эту точку пересечения как новую конечную точку отрезка. Укороченный отрезок снова пропускается через алгоритм.~\cite{REMOVE_FACES}\\

% \subsection{Алгоритм, использующий z-буфер}

Алгоритм, использующий $z$-буфер, работает в пространстве изображения. Идея $z$-буфера является простым обобщением идеи о буфере кадра. Буфер кадра используется для запоминания атрибутов (интенсивности) каждого пикселя в пространстве изображения, $z$-буфер --- это отдельный буфер глубины, используемый для запоминания координаты $z$ или глубины каждого видимого пикселя в пространстве изображения. В процессе работы глубина или значение $z$ каждого нового пикселя, который нужно занести в буфер кадра, сравнивается с глубиной того пикселя, который уже занесен в $z$-буфер. Если это сравнение показывает, что новый пиксель расположен впереди пикселя, находящегося в буфере кадра, то новый пиксель заносится в этот буфер и, кроме того, производится корректировка $z$-буфера новым значением $z$. Если же сравнение дает противоположный результат, то никаких действий не производится. По сути, алгоритм является поиском по $x$ и $y$ наибольшего значения функции $z(x, y)$.

Поскольку габариты пространства изображения фиксированы, оценка вычислительной трудоемкости алгоритма не более чем линейна. Так как элементы сцены или картинки можно заносить в буфер кадра или в $z$-буфер в произвольном порядке, их не нужно предварительно сортировать по приоритету глубины. Поэтому экономится вычислительное время, затрачиваемое на сортировку по глубине.

К недостаткам алгоритма относятся большой объем требуемой памяти и в высокой стоимости устранения лестничного эффекта, а также реализации эффектов прозрачности и просвечивания. Поскольку алгоритм заносит пиксели в буфер кадра в произвольном порядке, то нелегко получить информацию, необходимую для методов устранения лестничного эффекта, основывающихся на предварительной фильтрации. При реализации эффектов прозрачности и просвечивания пиксели могут заноситься в буфер кадра в некорректном порядке, что ведет к локальным ошибкам.~\cite{ZBuff}

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Сравнение алгоритмов удаления невидимых поверхностей}
			\label{tbl:test_rem_faces}
			\begin{tabular}{|c|c|c|}
				\hline
				\bfseries Алгоритм & \bfseries Асимптотика & \bfseries Типы объектов \\
				\hline
				Алгоритм Робертса & $O(n^2)$, где & Выпуклые многогранники \\
				& $n$ - число объектов & \\
				\hline
				Алгоритм плавающего горизонта & $O(x \cdot z)$, где & Вида $F(x, y, z) = 0$ \\
				& $x = x_{max} - x_{min}$ & \\
				& $z = z_{max} - z_{min}$ & \\
				\hline
				$z$-буфер & $O(w \cdot h)$, где & Произвольные \\
				& $w$ --- ширина экрана & \\
				& $h$ --- высота экрана & \\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

Среди рассмотренных алгоритмов~\cite{REMOVE_FACES, ZBuff}, для поставленной задачи больше всего подходит алгоритм $z$-буфера, так как он может работать со сценами любой сложности и не требует больших вычислительных мощностей для сцен с множеством объектов, что необходимо при реализации морфинга.

\newpage

\section{Анализ алгоритмов закраски}

Для придания реалистичности изображениям кроме удаления невидимых линий и поверхностей необходимо правильно отразить свет от присутствующих на сцене объектов. Существует несколько основных методов закрашивания изображаемых поверхностей. Среди них можно выделить~\cite{FILL_FACES}:

\begin{itemize}[label*=---]
	\item метод однотонной закраски;
	\item метод, основанный на интерполяции значений интенсивности освещенности поверхности --- метод Гуро;
	\item метод, основанный на интерполяции векторов нормалей к граням многогранника --- метод Фонга.
\end{itemize}

При однотонной закраски для изображаемого объекта вычисляется один уровень интенсивности освещения, который и используется для закраски всего объекта. Следует заметить, что, если каждая плоская грань имеет один постоянный цвет, то различные цвета соседних граней очень заметны, и поверхность выглядит как многогранник. Этот эффект можно сгладить, если увеличить число рассматриваемых граней. Так как зрение человека имеет способность подчеркивать перепады яркости на границах смежных граней (эффект Маха), для обеспечения иллюзии гладкой поверхности изображения нужно намного увеличить количество таких граней, а это приведет к снижению эффективности всей вычислительной процедуры.\\

Метод Гуро основывается на идее закрашивания каждой грани не одним цветом, а плавно изменяющимися оттенками, вычисляемыми путем интерполяции цветов примыкающих граней. Закрашивание граней по методу Гуро осуществляется в четыре этапа:

\begin{enumerate}
	\item Вычисляются нормали к поверхности;
	\item Определяются нормали в вершинах многогранника путем усреднения нормали по всем полигональным граням, которым принадлежит вершина;
	\item Используя нормали в вершинах и применяя произвольный метод закраски, вычисляют значения интенсивности освещения в вершинах;
	\item Каждый многоугольник закрашивают путем линейной интерполяции значений интенсивности в вершинах, сначала вдоль каждого ребра, а затем и между ребрами вдоль каждой сканирующей строки.
\end{enumerate}

\leavevmode

В методе закраски, разработанном Фонгом, используется интерполяция вектора нормали к поверхности вдоль видимого интервала на сканирующей строке внутри многоугольника, а не интерполяция интенсивности. Интерполяция выполняется между начальной и конечной нормалями, которые сами тоже являются результатами интерполяции вдоль ребер многоугольника между нормалями в вершинах. Нормали в вершинах, в свою очередь, вычисляются так же, как в методе закраски, построенном на основе интерполяции интенсивности.~\cite{FILL_FACES}

\includeimage
{FillDiff}
{f}
{!ht}
{0.8\textwidth}
{Визуальное сравнение различных алгоритмов закраски}

Наиболее подходящей закраской для поставленной задачи является закраска Гуро, так как программа подразумевает обработку моделей с большим количеством примитивов.

\newpage

\section{Анализ алгоритмов освещения}

К основным моделям освещения относятся модели Ламберта и Фонга~\cite{Zadorozhnyi}, построенные на основе трехкомпонентного освещения.\\

В общем виде модель освещения Фонга состоит из суммы фоновой, диффузной и зеркальной составляющей и имеет следующий вид:
\begin{equation}
	I = I_{a} + I_{d} + I_{s} = m_{a} \cdot L_{a} + m_{d} \cdot k_{d} \cdot L_{d} + m_{s} \cdot k_{s} \cdot L_{s}
\end{equation}

\leavevmode

В общем виде модель освещения Ламберта состоит из суммы фоновой и диффузной компонент:
\begin{equation}
	I = I_{a} + I_{d} = m_{a} \cdot L_{a} + m_{d} \cdot k_{d} \cdot L_{d}
\end{equation}

Модель Ламберта является одной из самых простых моделей освещения. Данная модель очень часто используется как часть других моделей, поскольку практически в любой другой модели освещения можно выделить диффузную составляющую. Более-менее равномерная часть освещения (без присутствия какого-либо всплеска), как правило, будет представляться моделью Ламберта с определенными характеристиками. Данная модель может быть очень удобна для анализа свойств других моделей (за счет того, что ее легко выделить из любой модели и анализировать оставшиеся составляющие).

В частности, модель Ламберта является существенной частью модели Фонга, которая представляет собой комбинацию диффузной составляющей (модели Ламберта) и зеркальной составляющей.~\cite{Zadorozhnyi}

\leavevmode

Наилучшим решением для поставленной задачи --- модель освещения Ламберта.

\newpage

\section{Анализ алгоритмов морфинга}

Среди алгоритмов морфинга можно выделить три алгоритма: линейный, слиянием и д-морфинг.\\

Линейный морфинг основан на линейной интерполяции между начальными и конечными позициями каждой точки или вершины модели. Алгоритм состоит из следующих этапов:

\begin{enumerate}
	\item Выравнивание вершин. Чтобы линейный морфинг работал корректно, у исходной и конечной моделей должны быть одинаковое количество вершин и морфологическая структура. Обычно это требует предварительного выравнивания вершин;
	\item Интерполяция позиций вершин. Процесс начинается с вычисления позиций каждой вершины на промежуточных этапах между исходной и конечной моделями. Используется линейная интерполяция, чтобы постепенно изменять координаты вершин по оси $x$, $y$ и $z$:
	\begin{equation}
		P_{t} = (1 - t) \cdot P_{0} + t \cdot P_{1},
	\end{equation}
	где \( P_{t} \) --- позиция вершины на промежуточном этапе, \( P_{0} \) --- позиция вершины в исходной модели, \( P_{1} \) --- позиция вершины в конечной модели, а \( t \) --- параметры интерполяции, принимающие значения от 0 до 1;
	\item Текстурирование и цвета. Наряду с изменением позиций вершин может также потребоваться интерполяция текстурных координат и цветов вершин, чтобы добиться качественного визуального эффекта;
	\item Анимация и кадры. Для создания анимации между двух моделей процесс интерполяции выполняется для каждого промежуточного кадра. Значение \( t \) увеличивается от 0 до 1 по мере прогресса анимации, что создает плавный переход.
\end{enumerate}

Данный алгоритм плохо справляется с задачей плавного перехода, если число вершин между исходной и итоговой моделями сильно разнится.~\cite{LinearMorph} \\

Алгоритм морфинга слиянием предполагает <<надувание>> исходного и итогового объектов до сферы. Оболочка каждого объекта проецируется на единичную сферу. Это отображение используется для идентификации соответствий между точками на двух исходных объектах путем связывания пар точек, которые отображаются в одно и то же место на сфере. Из этого этапа следует требование к объектам --  Затем две топологии объединяются путем обрезки спроецированных граней одной модели спроецированными гранями другой. Объединенная топология затем отображается на поверхность обеих исходных моделей. Это создает две новые модели, которые имеют ту же форму, что и исходные две модели, но которые разделяют общую топологию. Это позволяет легко вычислить преобразование между двумя формами путем интерполяции координат каждой пары соответствующих вершин.~\cite{Merging_Morph}

\includeimage
{MergedMorph}
{f}
{!ht}
{0.75\textwidth}
{Пара исходных моделей и та же пара с объединенными топологиями}

\leavevmode

Д-морфинг разделяется на два этапа: построение описывающих фигур и генерация морфинга.

На первом этапе строятся два новых объекта: исходная фигура, измененная с помощью паралельных переносов плоскостей, полностью включающая в себя итоговую, и наоборот.  Чтобы получить морфинг, мы просто перемещаем все плоскости одновременно из их начальных положений в их конечные положения. Форма, образованная их пересечением, будет кадром морфинга.~\cite{DMorph}

\begin{table}[ht]
	\small
	\begin{center}
		\begin{threeparttable}
			\caption{Сравнение алгоритмов морфинга}
			\label{tbl:test_morph}
			\begin{tabular}{|c|c|c|}
				\hline
				\bfseries Алгоритм & \bfseries Разность количества вершин & \bfseries Типы многогранников \\
				\hline
				Линейный морфинг & Чем больше, & Произвольные \\
				& тем хуже качество & \\
				\hline
				Морфинг слиянием & Не важна & Практически произвольные \\
				\hline
				Д-морфинг & Не важна & Выпуклые \\
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

Для поставленной задачи лучше всего подходит морфинг слиянием. Такой выбор обусловлен тем, что линейный морфинг хуже работает с объектами, имеющими разное количество вершин, а д-морфинг позволяет обрабатывать только выпуклые объекты.

\section*{Вывод}
В данном разделе проведен анализ существующих алгоритмов построения изображений и морфинга.