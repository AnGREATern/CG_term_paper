\chapter{Аналитический раздел}

В данном разделе проводится анализ существующих алгоритмов построения изображений и выбор подходящих алгоритмов для решения задачи.

\section{Формализация объектов сцены}
Сцена состоит из следующих объектов:

\begin{itemize}[label*=---]
	\item объект (стартовый или получаемый) --- трехмерная модель, представляющая собой каркасное тело;
	\item источник света --- вектор направления света;
	\item камера --- характеризуется своим положением и направлением просмотра.
\end{itemize}

\section{Анализ способов описания трехмерных моделей}

В компьютерной графике в основном используют три типа представления трехмерных объектов: каркасная, поверхностная и твердотельная модели.
Они предоставляют различные способы представления объектов и позволяют 
достичь правильного отображения их формы и размеров на сцене. %\cite{Kosnikov}

% \subsection{Каркасная модель}

Каркасная модель это простейший вид моделей. В этой модели задается информация о вершинах и рёбрах объектов. Этим видам модели присущ весьма существенный недостаток: не всегда модель правильно передает представление об объекте. К преимуществам же можно отнести сравнительно низкое число затрачиваемой памяти.

% \subsection{Поверхостная модель}

Поверхностные модели несут информацию обо всех точках
пространства, принадлежащих поверхности объекта, а внутренние точки в них
не учитываются. К недостаткам данной модели относится отсутствие информации о том, с какой стороны поверхности находится материал. % \cite{Kosnikov}

% \subsection{Твердотельная модель}

Твердотельная модель отличается от поверхностной наличием информации о том, где расположен материал. Проще всего это можно сделать путём указания направления внутренней нормали.

% \subsection{Выбор способа описания модели}

Для решения поставленной задачи наилучшим образом подойдет каркасная модель, так как для осуществления морфинга необходимо знать информацию только о вершинах и рёбрах объекта. Хранить остальную информацию об объекте избыточно. \cite{Kosnikov}

\section{Анализ алгоритмов удаления невидимых поверхностей}

Алгоритмы удаления невидимых линий и поверхностей определяют, какие линии, поверхности или объемы видимы или невидимы для наблюдателя, находящегося в определенной точке пространства.

% \subsection{Алгоритм Робертса}

Алгоритм Робертса удаляет из каждого тела те ребра или грани, которые скрываются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, скрываются этими телами. При этом вычислительная трудоемкость алгоритма Робертса растет теоретически, как квадрат числа объектов. При этом математические методы, используемые в этом алгоритме, просты, мощны и точны. %\cite{REMOVE_FACES}

% \subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта чаше всего используется для удаления невидимых линий трехмерного представления функций, описывающих поверхность в виде F(x, у, z) = 0.

Идея метода заключается в сведении трехмерной задачи к двумерной путем пересечения исходной поверхности последовательностью параллельных секущих плоскостей, имеющих постоянные значения координаты z.

Алгоритм сначала упорядочивает плоскости z = const по возрастанию расстояния до них от точки наблюдения. Затем для каждой плоскости, начиная с ближайшей к точке наблюдения, строится кривая, лежащая на ней, т.е. для каждого значения координаты х в пространстве изображения определяется соответствующее значение y.

Если на текущей плоскости при некотором заданном значении x соответствующее значение у на кривой больше значения y для всех предыдущих кривых при этом значении x, то текущая кривая видима в этой точке; в противном случае она невидима. %\cite{REMOVE_FACES}

% \subsection{Алгоритм Коэна --- Сазерленда}

Алгоритм Коэна --- Сазерленда разделяет плоскость на девять частей прямыми, которые образуют стороны прямоугольника. Каждой из девяти частей присваивается четырехбитный код.

Окну присваивается код 0000. Конечным точкам отрезка приписывается 4-битный код "вне/внутри" в зависимости от нахождения отрезка в соответствующей подобласти. Каждому биту присваивается значение 1 в соответствии со следующим правилом.

Бит 1 --- точка находится выше окна;

Бит 2 --- точка находится ниже окна;

Бит 3 --- точка находится справа от окна;

Бит 4 --- точка находится слева от окна;

Иначе биту присваивается нулевое значение.

\includeimage
{CohenSutherland}
{f}
{!ht}
{0.50\textwidth}
{Разбиение на подобласти в методе Коэна---Сазерленда}

Алгоритм определяет код конечных точек отрезка. Если оба кода равны нулю, то отрезок полностью находится в прямоугольнике. Если битовое И кодов не равно нулю, то отрезок не пересекает прямоугольник (так как это значит, что обе конечные точки отрезка находятся с одной стороны прямоугольника). В прочих случаях алгоритм выбирает конечную точку, находящуюся вне прямоугольника, находит ближайшую к ней точку пересечения отрезка с одной из линий, образующей стороны прямоугольника, и использует эту точку пересечения как новую конечную точку отрезка. Укороченный отрезок снова пропускается через алгоритм. \cite{REMOVE_FACES}

\section{Анализ алгоритмов закраски}



